(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{496:function(t,e,s){"use strict";s.r(e),s.d(e,"default",(function(){return T}));
/*! MIT License Â© Sindre Sorhus */
const o={},r=t=>"undefined"!=typeof self&&self&&t in self?self:"undefined"!=typeof window&&window&&t in window?window:"undefined"!=typeof global&&global&&t in global?global:"undefined"!=typeof globalThis&&globalThis?globalThis:void 0,n=["Headers","Request","Response","ReadableStream","fetch","AbortController","FormData"];for(const t of n)Object.defineProperty(o,t,{get(){const e=r(t),s=e&&e[t];return"function"==typeof s?s.bind(e):s}});const i=t=>null!==t&&"object"==typeof t,a="function"==typeof o.AbortController,h="function"==typeof o.ReadableStream,u="function"==typeof o.FormData,p=(t,e)=>{const s=new o.Headers(t||{}),r=e instanceof o.Headers,n=new o.Headers(e||{});for(const[t,e]of n)r&&"undefined"===e||void 0===e?s.delete(t):s.set(t,e);return s},f=(...t)=>{let e={},s={};for(const o of t){if(Array.isArray(o))Array.isArray(e)||(e=[]),e=[...e,...o];else if(i(o)){for(let[t,s]of Object.entries(o))i(s)&&Reflect.has(e,t)&&(s=f(e[t],s)),e={...e,[t]:s};i(o.headers)&&(s=p(s,o.headers))}e.headers=s}return e},c=["get","post","put","patch","head","delete"],d={json:"application/json",text:"text/*",formData:"multipart/form-data",arrayBuffer:"*/*",blob:"*/*"},l=[413,429,503],y=Symbol("stop");class w extends Error{constructor(t){super(t.statusText||String(0===t.status||t.status?t.status:"Unknown response error")),this.name="HTTPError",this.response=t}}class _ extends Error{constructor(t){super("Request timed out"),this.name="TimeoutError",this.request=t}}const m=t=>new Promise(e=>setTimeout(e,t)),b=t=>c.includes(t)?t.toUpperCase():t,g={limit:2,methods:["get","put","head","delete","options","trace"],statusCodes:[408,413,429,500,502,503,504],afterStatusCodes:l},R=(t={})=>{if("number"==typeof t)return{...g,limit:t};if(t.methods&&!Array.isArray(t.methods))throw new Error("retry.methods must be an array");if(t.statusCodes&&!Array.isArray(t.statusCodes))throw new Error("retry.statusCodes must be an array");return{...g,...t,afterStatusCodes:l}};class q{constructor(t,e={}){if(this._retryCount=0,this._input=t,this._options={credentials:this._input.credentials||"same-origin",...e,headers:p(this._input.headers,e.headers),hooks:f({beforeRequest:[],beforeRetry:[],afterResponse:[]},e.hooks),method:b(e.method||this._input.method),prefixUrl:String(e.prefixUrl||""),retry:R(e.retry),throwHttpErrors:!1!==e.throwHttpErrors,timeout:void 0===e.timeout?1e4:e.timeout,fetch:e.fetch||o.fetch},"string"!=typeof this._input&&!(this._input instanceof URL||this._input instanceof o.Request))throw new TypeError("`input` must be a string, URL, or Request");if(this._options.prefixUrl&&"string"==typeof this._input){if(this._input.startsWith("/"))throw new Error("`input` must not begin with a slash when using `prefixUrl`");this._options.prefixUrl.endsWith("/")||(this._options.prefixUrl+="/"),this._input=this._options.prefixUrl+this._input}if(a&&(this.abortController=new o.AbortController,this._options.signal&&this._options.signal.addEventListener("abort",()=>{this.abortController.abort()}),this._options.signal=this.abortController.signal),this.request=new o.Request(this._input,this._options),this._options.searchParams){const t="?"+new URLSearchParams(this._options.searchParams).toString(),e=this.request.url.replace(/(?:\?.*?)?(?=#|$)/,t);!(u&&this._options.body instanceof o.FormData||this._options.body instanceof URLSearchParams)||this._options.headers&&this._options.headers["content-type"]||this.request.headers.delete("content-type"),this.request=new o.Request(new o.Request(e,this.request),this._options)}void 0!==this._options.json&&(this._options.body=JSON.stringify(this._options.json),this.request.headers.set("content-type","application/json"),this.request=new o.Request(this.request,{body:this._options.body}));const s=async()=>{if(this._options.timeout>2147483647)throw new RangeError("The `timeout` option cannot be greater than 2147483647");await m(1);let t=await this._fetch();for(const e of this._options.hooks.afterResponse){const s=await e(this.request,this._options,this._decorateResponse(t.clone()));s instanceof o.Response&&(t=s)}if(this._decorateResponse(t),!t.ok&&this._options.throwHttpErrors)throw new w(t);if(this._options.onDownloadProgress){if("function"!=typeof this._options.onDownloadProgress)throw new TypeError("The `onDownloadProgress` option must be a function");if(!h)throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");return this._stream(t.clone(),this._options.onDownloadProgress)}return t},r=this._options.retry.methods.includes(this.request.method.toLowerCase())?this._retry(s):s();for(const[t,s]of Object.entries(d))r[t]=async()=>{this.request.headers.set("accept",this.request.headers.get("accept")||s);const o=(await r).clone();if("json"===t){if(204===o.status)return"";if(e.parseJson)return e.parseJson(await o.text())}return o[t]()};return r}_calculateRetryDelay(t){if(this._retryCount++,this._retryCount<this._options.retry.limit&&!(t instanceof _)){if(t instanceof w){if(!this._options.retry.statusCodes.includes(t.response.status))return 0;const e=t.response.headers.get("Retry-After");if(e&&this._options.retry.afterStatusCodes.includes(t.response.status)){let t=Number(e);return Number.isNaN(t)?t=Date.parse(e)-Date.now():t*=1e3,void 0!==this._options.retry.maxRetryAfter&&t>this._options.retry.maxRetryAfter?0:t}if(413===t.response.status)return 0}return.3*2**(this._retryCount-1)*1e3}return 0}_decorateResponse(t){return this._options.parseJson&&(t.json=async()=>this._options.parseJson(await t.text())),t}async _retry(t){try{return await t()}catch(e){const s=Math.min(this._calculateRetryDelay(e),2147483647);if(0!==s&&this._retryCount>0){await m(s);for(const t of this._options.hooks.beforeRetry){if(await t({request:this.request,options:this._options,error:e,retryCount:this._retryCount})===y)return}return this._retry(t)}if(this._options.throwHttpErrors)throw e}}async _fetch(){for(const t of this._options.hooks.beforeRequest){const e=await t(this.request,this._options);if(e instanceof Request){this.request=e;break}if(e instanceof Response)return e}return!1===this._options.timeout?this._options.fetch(this.request.clone()):(t=this.request.clone(),e=this.abortController,s=this._options,new Promise((o,r)=>{const n=setTimeout(()=>{e&&e.abort(),r(new _(t))},s.timeout);s.fetch(t).then(o).catch(r).then(()=>{clearTimeout(n)})}));var t,e,s}_stream(t,e){const s=Number(t.headers.get("content-length"))||0;let r=0;return new o.Response(new o.ReadableStream({start(o){const n=t.body.getReader();e&&e({percent:0,transferredBytes:0,totalBytes:s},new Uint8Array),async function t(){const{done:i,value:a}=await n.read();if(i)o.close();else{if(e){r+=a.byteLength;e({percent:0===s?0:r/s,transferredBytes:r,totalBytes:s},a)}o.enqueue(a),t()}}()}}))}}const C=(...t)=>{for(const e of t)if((!i(e)||Array.isArray(e))&&void 0!==e)throw new TypeError("The `options` argument must be an object");return f({},...t)},E=t=>{const e=(e,s)=>new q(e,C(t,s));for(const s of c)e[s]=(e,o)=>new q(e,C(t,o,{method:s}));return e.HTTPError=w,e.TimeoutError=_,e.create=t=>E(C(t)),e.extend=e=>E(C(t,e)),e.stop=y,e};var T=E()}}]);